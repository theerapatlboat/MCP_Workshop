import asyncio
import hashlib
import hmac
import json
import os
import sys
import time
from dataclasses import dataclass, field
from pathlib import Path

import httpx
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Query, Request
from fastapi.responses import HTMLResponse, PlainTextResponse

load_dotenv()

# Add project root for shared imports
_PROJECT_ROOT = str(Path(__file__).resolve().parent.parent)
if _PROJECT_ROOT not in sys.path:
    sys.path.insert(0, _PROJECT_ROOT)

from shared.constants import ERROR_SYSTEM_UNAVAILABLE_SHORT
from shared.http_client import forward_to_agent as _forward_to_agent
from shared.logging_setup import setup_logger

FB_VERIFY_TOKEN = os.getenv("FB_VERIFY_TOKEN", "")
FB_APP_SECRET = os.getenv("FB_APP_SECRET", "")
FB_PAGE_ACCESS_TOKEN = os.getenv("FB_PAGE_ACCESS_TOKEN", "")
AI_AGENT_URL = os.getenv("AI_AGENT_URL", "http://localhost:8000/chat")

GRAPH_API_URL = "https://graph.facebook.com/v24.0/me/messages"

# ---------------------------------------------------------------------------
# Debounce configuration
# ---------------------------------------------------------------------------
DEBOUNCE_DELAY_SECONDS = float(os.getenv("DEBOUNCE_DELAY_SECONDS", "45"))
DEBOUNCE_MAX_WAIT_SECONDS = float(os.getenv("DEBOUNCE_MAX_WAIT_SECONDS", "180"))
DEBOUNCE_MAX_BUFFER_SIZE = int(os.getenv("DEBOUNCE_MAX_BUFFER_SIZE", "20"))
DEBOUNCE_MAX_BUFFER_CHARS = int(os.getenv("DEBOUNCE_MAX_BUFFER_CHARS", "4000"))

# ---------------------------------------------------------------------------
# Facebook Attachment ID mapping (generated by upload_images.py)
# ---------------------------------------------------------------------------
FB_ATTACHMENT_IDS_PATH = Path(__file__).parent / "fb_attachment_ids.json"
fb_attachment_ids: dict[str, str] = {}

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------
logger = setup_logger("webhook", Path(__file__).parent / "logs", "webhook.log")

# ---------------------------------------------------------------------------
# FastAPI app
# ---------------------------------------------------------------------------
app = FastAPI(title="Facebook Messenger Webhook")

# ---------------------------------------------------------------------------
# Message deduplication (prevents processing Facebook webhook retries)
# ---------------------------------------------------------------------------
_seen_mids: dict[str, float] = {}
_DEDUP_TTL_SECONDS = 300  # 5 minutes


def _is_duplicate(mid: str) -> bool:
    """Return True if this mid was already processed. Auto-cleans expired entries."""
    now = time.time()
    if len(_seen_mids) > 100:
        expired = [k for k, ts in _seen_mids.items() if now - ts > _DEDUP_TTL_SECONDS]
        for k in expired:
            del _seen_mids[k]
    if mid in _seen_mids:
        return True
    _seen_mids[mid] = now
    return False

# ---------------------------------------------------------------------------
# Debounce state (per-user message accumulation)
# ---------------------------------------------------------------------------
@dataclass
class _UserDebounceState:
    """Mutable debounce state for a single user."""

    messages: list[str] = field(default_factory=list)
    timer_task: asyncio.Task | None = None
    first_message_time: float = 0.0
    last_message_time: float = 0.0
    lock: asyncio.Lock = field(default_factory=asyncio.Lock)


_debounce_state: dict[str, _UserDebounceState] = {}

STATIC_DIR = Path(__file__).parent / "static"


# ---------------------------------------------------------------------------
# Startup — load attachment mapping
# ---------------------------------------------------------------------------
@app.on_event("startup")
async def startup():
    global fb_attachment_ids
    if FB_ATTACHMENT_IDS_PATH.exists():
        with open(FB_ATTACHMENT_IDS_PATH, "r", encoding="utf-8") as f:
            fb_attachment_ids = json.load(f)
        logger.info("Loaded %d Facebook attachment IDs from %s", len(fb_attachment_ids), FB_ATTACHMENT_IDS_PATH.name)
    else:
        logger.warning("fb_attachment_ids.json not found — images will not be sent to Messenger")

    # Start periodic debounce cleanup
    asyncio.create_task(_debounce_cleanup_stale())


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
def verify_signature(payload: bytes, signature_header: str) -> bool:
    """Verify X-Hub-Signature-256 using HMAC SHA-256."""
    if not signature_header or not signature_header.startswith("sha256="):
        return False
    expected = hmac.new(
        FB_APP_SECRET.encode(), payload, hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(expected, signature_header.removeprefix("sha256="))


async def send_message(recipient_id: str, text: str) -> None:
    """Send a text message via the Facebook Send API."""
    payload = {
        "recipient": {"id": recipient_id},
        "message": {"text": text},
    }
    async with httpx.AsyncClient() as client:
        resp = await client.post(
            GRAPH_API_URL,
            params={"access_token": FB_PAGE_ACCESS_TOKEN},
            json=payload,
            timeout=10,
        )
    if resp.status_code != 200:
        logger.error("Send API error %s: %s", resp.status_code, resp.text)
    else:
        logger.info("Message sent to %s", recipient_id)


async def send_image(recipient_id: str, attachment_id: str) -> bool:
    """Send an image attachment via the Facebook Send API using a reusable attachment_id."""
    payload = {
        "recipient": {"id": recipient_id},
        "message": {
            "attachment": {
                "type": "image",
                "payload": {
                    "attachment_id": attachment_id
                }
            }
        },
    }
    async with httpx.AsyncClient() as client:
        resp = await client.post(
            GRAPH_API_URL,
            params={"access_token": FB_PAGE_ACCESS_TOKEN},
            json=payload,
            timeout=10,
        )
    if resp.status_code != 200:
        logger.error("Send image error %s: %s", resp.status_code, resp.text)
        return False
    else:
        logger.info("Image sent to %s (attachment_id=%s)", recipient_id, attachment_id[:20])
        return True


async def send_images(recipient_id: str, image_ids: list[str]) -> None:
    """Send multiple images to the user, looking up attachment_ids from mapping."""
    for image_id in image_ids:
        attachment_id = fb_attachment_ids.get(image_id)
        if not attachment_id:
            logger.warning("No Facebook attachment_id for image %s — skipping", image_id)
            continue
        await send_image(recipient_id, attachment_id)


async def forward_to_agent(sender_id: str, text: str) -> tuple[str, list[str]]:
    """Forward the user message to the AI Agent and return (reply_text, image_ids)."""
    try:
        result = await _forward_to_agent(AI_AGENT_URL, sender_id, text)
        return result["response"], result["image_ids"]
    except Exception as exc:
        logger.error("AI Agent request failed: %s", exc)
        return ERROR_SYSTEM_UNAVAILABLE_SHORT, []


async def send_typing_indicator(recipient_id: str) -> None:
    """Send typing_on sender action to Facebook."""
    payload = {
        "recipient": {"id": recipient_id},
        "sender_action": "typing_on",
    }
    try:
        async with httpx.AsyncClient() as client:
            await client.post(
                GRAPH_API_URL,
                params={"access_token": FB_PAGE_ACCESS_TOKEN},
                json=payload,
                timeout=5,
            )
    except Exception:
        logger.debug("Failed to send typing indicator to %s", recipient_id)


# ---------------------------------------------------------------------------
# Debounce — accumulate rapid messages per user, process after silence
# ---------------------------------------------------------------------------


async def _debounce_enqueue(sender_id: str, text: str) -> None:
    """Add a message to the user's debounce buffer and (re)start the timer."""
    if sender_id not in _debounce_state:
        _debounce_state[sender_id] = _UserDebounceState()

    state = _debounce_state[sender_id]

    async with state.lock:
        now = time.time()

        if not state.messages:
            state.first_message_time = now
        state.last_message_time = now

        # Force flush: buffer size limit
        if len(state.messages) >= DEBOUNCE_MAX_BUFFER_SIZE:
            logger.warning(
                "Debounce buffer full for %s (%d messages) — forcing flush",
                sender_id,
                len(state.messages),
            )
            if state.timer_task and not state.timer_task.done():
                state.timer_task.cancel()
            state.messages.append(text)
            state.timer_task = asyncio.create_task(_debounce_process(sender_id))
            return

        # Force flush: character limit
        total_chars = sum(len(m) for m in state.messages) + len(text)
        if total_chars > DEBOUNCE_MAX_BUFFER_CHARS:
            logger.warning(
                "Debounce buffer chars exceeded for %s (%d chars) — forcing flush",
                sender_id,
                total_chars,
            )
            if state.timer_task and not state.timer_task.done():
                state.timer_task.cancel()
            state.messages.append(text)
            state.timer_task = asyncio.create_task(_debounce_process(sender_id))
            return

        # Force flush: absolute max wait time
        elapsed = now - state.first_message_time
        if state.messages and elapsed >= DEBOUNCE_MAX_WAIT_SECONDS:
            logger.info(
                "Debounce max wait reached for %s (%.0fs) — forcing flush",
                sender_id,
                elapsed,
            )
            if state.timer_task and not state.timer_task.done():
                state.timer_task.cancel()
            state.messages.append(text)
            state.timer_task = asyncio.create_task(_debounce_process(sender_id))
            return

        # Normal path: append message and (re)start timer
        state.messages.append(text)

        if state.timer_task and not state.timer_task.done():
            state.timer_task.cancel()
            logger.debug(
                "Debounce timer reset for %s (now %d messages buffered)",
                sender_id,
                len(state.messages),
            )

        state.timer_task = asyncio.create_task(
            _debounce_wait_and_process(sender_id)
        )

        # Typing indicator — fire-and-forget
        asyncio.create_task(send_typing_indicator(sender_id))

        logger.info(
            "Debounce: buffered message %d for %s (window %.0fs)",
            len(state.messages),
            sender_id,
            now - state.first_message_time if len(state.messages) > 1 else 0,
        )


async def _debounce_wait_and_process(sender_id: str) -> None:
    """Wait for the debounce delay, then process accumulated messages."""
    try:
        await asyncio.sleep(DEBOUNCE_DELAY_SECONDS)
    except asyncio.CancelledError:
        return  # Timer reset by a new message — normal, not an error
    await _debounce_process(sender_id)


async def _debounce_process(sender_id: str) -> None:
    """Drain the debounce buffer and forward combined message to the agent."""
    state = _debounce_state.get(sender_id)
    if not state:
        return

    async with state.lock:
        if not state.messages:
            return
        combined_messages = state.messages.copy()
        first_time = state.first_message_time
        state.messages.clear()
        state.first_message_time = 0.0
        state.last_message_time = 0.0
        state.timer_task = None

    combined_text = "\n".join(combined_messages)

    logger.info(
        "Debounce: processing %d messages for %s (combined %d chars, waited %.0fs)",
        len(combined_messages),
        sender_id,
        len(combined_text),
        time.time() - first_time,
    )

    await send_typing_indicator(sender_id)

    try:
        reply, image_ids = await forward_to_agent(sender_id, combined_text)
        if reply:
            await send_message(sender_id, reply)
        if image_ids:
            await send_images(sender_id, image_ids)
    except Exception:
        logger.exception(
            "Debounce: failed to process %d messages for %s — messages: %s",
            len(combined_messages),
            sender_id,
            [m[:50] for m in combined_messages],
        )
        try:
            await send_message(sender_id, ERROR_SYSTEM_UNAVAILABLE_SHORT)
        except Exception:
            logger.exception("Failed to send error message to %s", sender_id)
    finally:
        # Clean up state if buffer is still empty (no new messages during processing)
        if sender_id in _debounce_state:
            async with _debounce_state[sender_id].lock:
                if not _debounce_state[sender_id].messages:
                    del _debounce_state[sender_id]
                    logger.debug("Debounce: cleaned up state for %s", sender_id)


async def _debounce_cleanup_stale() -> None:
    """Periodic cleanup of stale debounce entries (runs every 5 minutes)."""
    while True:
        await asyncio.sleep(300)
        now = time.time()
        stale_threshold = DEBOUNCE_MAX_WAIT_SECONDS * 2
        stale_keys = []
        for sender_id, state in list(_debounce_state.items()):
            if state.last_message_time and (now - state.last_message_time) > stale_threshold:
                if not state.messages:
                    stale_keys.append(sender_id)
                else:
                    logger.warning(
                        "Debounce: found %d orphaned messages for %s — force processing",
                        len(state.messages),
                        sender_id,
                    )
                    asyncio.create_task(_debounce_process(sender_id))
        for key in stale_keys:
            _debounce_state.pop(key, None)
        if stale_keys:
            logger.info("Debounce cleanup: removed %d stale entries", len(stale_keys))


# ---------------------------------------------------------------------------
# Routes
# ---------------------------------------------------------------------------
@app.get("/webhook")
async def verify_webhook(
    request: Request,
    hub_mode: str | None = Query(None, alias="hub.mode"),
    hub_verify_token: str | None = Query(None, alias="hub.verify_token"),
    hub_challenge: str | None = Query(None, alias="hub.challenge"),
):
    """Webhook verification endpoint required by Facebook."""
    logger.info("GET /webhook  mode=%s  token=%s", hub_mode, hub_verify_token)

    if hub_mode == "subscribe" and hub_verify_token == FB_VERIFY_TOKEN:
        logger.info("Webhook verified successfully")
        return PlainTextResponse(hub_challenge)

    logger.warning("Webhook verification failed")
    raise HTTPException(status_code=403, detail="Verification failed")


async def _process_messaging_event(event: dict) -> None:
    """Process a single messaging event in the background."""
    try:
        sender_id = event.get("sender", {}).get("id")
        recipient_id = event.get("recipient", {}).get("id")

        # Skip echo messages
        message = event.get("message", {})
        if message.get("is_echo"):
            logger.info("Skipping echo message from %s", sender_id)
            return

        # Deduplicate by message mid
        mid = message.get("mid")
        if mid and _is_duplicate(mid):
            logger.info("Skipping duplicate mid=%s from %s", mid[:30], sender_id)
            return

        # Text message — route through debounce
        text = message.get("text")
        if text:
            logger.info(
                "Message from %s to %s: %s", sender_id, recipient_id, text
            )
            await _debounce_enqueue(sender_id, text)

        # Attachments
        attachments = message.get("attachments")
        if attachments:
            logger.info(
                "Attachments from %s: %s",
                sender_id,
                [a.get("type") for a in attachments],
            )

        # Postback
        postback = event.get("postback")
        if postback:
            logger.info(
                "Postback from %s: title=%s payload=%s",
                sender_id,
                postback.get("title"),
                postback.get("payload"),
            )
            reply, image_ids = await forward_to_agent(
                sender_id, postback.get("payload", "")
            )
            if reply:
                await send_message(sender_id, reply)
            if image_ids:
                await send_images(sender_id, image_ids)
    except Exception:
        logger.exception("Unhandled error processing messaging event")


@app.post("/webhook")
async def receive_webhook(request: Request):
    """Receive and process webhook events from Facebook."""
    body = await request.body()

    # Verify signature
    signature = request.headers.get("X-Hub-Signature-256", "")
    if FB_APP_SECRET and not verify_signature(body, signature):
        logger.warning("Invalid signature")
        raise HTTPException(status_code=403, detail="Invalid signature")

    data = await request.json()
    logger.info("Webhook event received")

    if data.get("object") != "page":
        raise HTTPException(status_code=404, detail="Not a page event")

    # Spawn background tasks — return 200 immediately so Facebook won't retry
    for entry in data.get("entry", []):
        for event in entry.get("messaging", []):
            asyncio.create_task(_process_messaging_event(event))

    return PlainTextResponse("EVENT_RECEIVED")


# ---------------------------------------------------------------------------
# Static pages for Facebook App Review
# ---------------------------------------------------------------------------
@app.get("/privacy", response_class=HTMLResponse)
async def privacy_policy():
    return (STATIC_DIR / "privacy.html").read_text(encoding="utf-8")


@app.get("/terms", response_class=HTMLResponse)
async def terms_of_service():
    return (STATIC_DIR / "terms.html").read_text(encoding="utf-8")


# ---------------------------------------------------------------------------
# Run
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    import uvicorn

    uvicorn.run("main:app", host="0.0.0.0", port=8001, reload=True)
