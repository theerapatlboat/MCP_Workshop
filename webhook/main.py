import asyncio
import hashlib
import hmac
import json
import logging
import os
import time
from logging.handlers import RotatingFileHandler
from pathlib import Path

import httpx
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Query, Request
from fastapi.responses import HTMLResponse, PlainTextResponse

load_dotenv()

FB_VERIFY_TOKEN = os.getenv("FB_VERIFY_TOKEN", "")
FB_APP_SECRET = os.getenv("FB_APP_SECRET", "")
FB_PAGE_ACCESS_TOKEN = os.getenv("FB_PAGE_ACCESS_TOKEN", "")
AI_AGENT_URL = os.getenv("AI_AGENT_URL", "http://localhost:8000/chat")

GRAPH_API_URL = "https://graph.facebook.com/v24.0/me/messages"

# ---------------------------------------------------------------------------
# Facebook Attachment ID mapping (generated by upload_images.py)
# ---------------------------------------------------------------------------
FB_ATTACHMENT_IDS_PATH = Path(__file__).parent / "fb_attachment_ids.json"
fb_attachment_ids: dict[str, str] = {}

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------
LOG_DIR = Path(__file__).parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

logger = logging.getLogger("webhook")
logger.setLevel(logging.INFO)

if not logger.handlers:
    formatter = logging.Formatter("%(asctime)s | %(levelname)-8s | %(message)s")

    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    file_handler = RotatingFileHandler(
        LOG_DIR / "webhook.log", maxBytes=5_000_000, backupCount=3, encoding="utf-8"
    )
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

# ---------------------------------------------------------------------------
# FastAPI app
# ---------------------------------------------------------------------------
app = FastAPI(title="Facebook Messenger Webhook")

# ---------------------------------------------------------------------------
# Message deduplication (prevents processing Facebook webhook retries)
# ---------------------------------------------------------------------------
_seen_mids: dict[str, float] = {}
_DEDUP_TTL_SECONDS = 300  # 5 minutes


def _is_duplicate(mid: str) -> bool:
    """Return True if this mid was already processed. Auto-cleans expired entries."""
    now = time.time()
    if len(_seen_mids) > 100:
        expired = [k for k, ts in _seen_mids.items() if now - ts > _DEDUP_TTL_SECONDS]
        for k in expired:
            del _seen_mids[k]
    if mid in _seen_mids:
        return True
    _seen_mids[mid] = now
    return False

STATIC_DIR = Path(__file__).parent / "static"


# ---------------------------------------------------------------------------
# Startup — load attachment mapping
# ---------------------------------------------------------------------------
@app.on_event("startup")
async def startup():
    global fb_attachment_ids
    if FB_ATTACHMENT_IDS_PATH.exists():
        with open(FB_ATTACHMENT_IDS_PATH, "r", encoding="utf-8") as f:
            fb_attachment_ids = json.load(f)
        logger.info("Loaded %d Facebook attachment IDs from %s", len(fb_attachment_ids), FB_ATTACHMENT_IDS_PATH.name)
    else:
        logger.warning("fb_attachment_ids.json not found — images will not be sent to Messenger")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
def verify_signature(payload: bytes, signature_header: str) -> bool:
    """Verify X-Hub-Signature-256 using HMAC SHA-256."""
    if not signature_header or not signature_header.startswith("sha256="):
        return False
    expected = hmac.new(
        FB_APP_SECRET.encode(), payload, hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(expected, signature_header.removeprefix("sha256="))


async def send_message(recipient_id: str, text: str) -> None:
    """Send a text message via the Facebook Send API."""
    payload = {
        "recipient": {"id": recipient_id},
        "message": {"text": text},
    }
    async with httpx.AsyncClient() as client:
        resp = await client.post(
            GRAPH_API_URL,
            params={"access_token": FB_PAGE_ACCESS_TOKEN},
            json=payload,
            timeout=10,
        )
    if resp.status_code != 200:
        logger.error("Send API error %s: %s", resp.status_code, resp.text)
    else:
        logger.info("Message sent to %s", recipient_id)


async def send_image(recipient_id: str, attachment_id: str) -> bool:
    """Send an image attachment via the Facebook Send API using a reusable attachment_id."""
    payload = {
        "recipient": {"id": recipient_id},
        "message": {
            "attachment": {
                "type": "image",
                "payload": {
                    "attachment_id": attachment_id
                }
            }
        },
    }
    async with httpx.AsyncClient() as client:
        resp = await client.post(
            GRAPH_API_URL,
            params={"access_token": FB_PAGE_ACCESS_TOKEN},
            json=payload,
            timeout=10,
        )
    if resp.status_code != 200:
        logger.error("Send image error %s: %s", resp.status_code, resp.text)
        return False
    else:
        logger.info("Image sent to %s (attachment_id=%s)", recipient_id, attachment_id[:20])
        return True


async def send_images(recipient_id: str, image_ids: list[str]) -> None:
    """Send multiple images to the user, looking up attachment_ids from mapping."""
    for image_id in image_ids:
        attachment_id = fb_attachment_ids.get(image_id)
        if not attachment_id:
            logger.warning("No Facebook attachment_id for image %s — skipping", image_id)
            continue
        await send_image(recipient_id, attachment_id)


async def forward_to_agent(sender_id: str, text: str) -> tuple[str, list[str]]:
    """Forward the user message to the AI Agent and return (reply_text, image_ids)."""
    try:
        async with httpx.AsyncClient() as client:
            resp = await client.post(
                AI_AGENT_URL,
                json={"session_id": sender_id, "message": text},
                timeout=30,
            )
            resp.raise_for_status()
            data = resp.json()
            reply = data.get("response", data.get("reply", ""))
            image_ids = data.get("image_ids", [])
            return reply, image_ids
    except Exception as exc:
        logger.error("AI Agent request failed: %s", exc)
        return "ขออภัย ระบบไม่สามารถประมวลผลได้ในขณะนี้", []


# ---------------------------------------------------------------------------
# Routes
# ---------------------------------------------------------------------------
@app.get("/webhook")
async def verify_webhook(
    request: Request,
    hub_mode: str | None = Query(None, alias="hub.mode"),
    hub_verify_token: str | None = Query(None, alias="hub.verify_token"),
    hub_challenge: str | None = Query(None, alias="hub.challenge"),
):
    """Webhook verification endpoint required by Facebook."""
    logger.info("GET /webhook  mode=%s  token=%s", hub_mode, hub_verify_token)

    if hub_mode == "subscribe" and hub_verify_token == FB_VERIFY_TOKEN:
        logger.info("Webhook verified successfully")
        return PlainTextResponse(hub_challenge)

    logger.warning("Webhook verification failed")
    raise HTTPException(status_code=403, detail="Verification failed")


async def _process_messaging_event(event: dict) -> None:
    """Process a single messaging event in the background."""
    try:
        sender_id = event.get("sender", {}).get("id")
        recipient_id = event.get("recipient", {}).get("id")

        # Skip echo messages
        message = event.get("message", {})
        if message.get("is_echo"):
            logger.info("Skipping echo message from %s", sender_id)
            return

        # Deduplicate by message mid
        mid = message.get("mid")
        if mid and _is_duplicate(mid):
            logger.info("Skipping duplicate mid=%s from %s", mid[:30], sender_id)
            return

        # Text message
        text = message.get("text")
        if text:
            logger.info(
                "Message from %s to %s: %s", sender_id, recipient_id, text
            )
            reply, image_ids = await forward_to_agent(sender_id, text)
            if reply:
                await send_message(sender_id, reply)
            if image_ids:
                await send_images(sender_id, image_ids)

        # Attachments
        attachments = message.get("attachments")
        if attachments:
            logger.info(
                "Attachments from %s: %s",
                sender_id,
                [a.get("type") for a in attachments],
            )

        # Postback
        postback = event.get("postback")
        if postback:
            logger.info(
                "Postback from %s: title=%s payload=%s",
                sender_id,
                postback.get("title"),
                postback.get("payload"),
            )
            reply, image_ids = await forward_to_agent(
                sender_id, postback.get("payload", "")
            )
            if reply:
                await send_message(sender_id, reply)
            if image_ids:
                await send_images(sender_id, image_ids)
    except Exception:
        logger.exception("Unhandled error processing messaging event")


@app.post("/webhook")
async def receive_webhook(request: Request):
    """Receive and process webhook events from Facebook."""
    body = await request.body()

    # Verify signature
    signature = request.headers.get("X-Hub-Signature-256", "")
    if FB_APP_SECRET and not verify_signature(body, signature):
        logger.warning("Invalid signature")
        raise HTTPException(status_code=403, detail="Invalid signature")

    data = await request.json()
    logger.info("Webhook event received")

    if data.get("object") != "page":
        raise HTTPException(status_code=404, detail="Not a page event")

    # Spawn background tasks — return 200 immediately so Facebook won't retry
    for entry in data.get("entry", []):
        for event in entry.get("messaging", []):
            asyncio.create_task(_process_messaging_event(event))

    return PlainTextResponse("EVENT_RECEIVED")


# ---------------------------------------------------------------------------
# Static pages for Facebook App Review
# ---------------------------------------------------------------------------
@app.get("/privacy", response_class=HTMLResponse)
async def privacy_policy():
    return (STATIC_DIR / "privacy.html").read_text(encoding="utf-8")


@app.get("/terms", response_class=HTMLResponse)
async def terms_of_service():
    return (STATIC_DIR / "terms.html").read_text(encoding="utf-8")


# ---------------------------------------------------------------------------
# Run
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    import uvicorn

    uvicorn.run("main:app", host="0.0.0.0", port=8001, reload=True)
